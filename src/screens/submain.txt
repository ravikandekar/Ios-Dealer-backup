import React, { useContext, useEffect, useState, useRef, useCallback } from 'react';
import { ScrollView, StyleSheet, View, TouchableOpacity, Platform, Alert, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { DetailsHeader } from '../components/DetailsHeader';
import DynamicTabView from '../components/DynamicTabView';
import { AuthContext } from '../context/AuthContext';
import SubscriptionCard from '../components/SubscriptionCard';
import SubscriptionPlanCard from '../components/SubscritptionPlanCard';
import {
  widthPercentageToDP as wp,
  heightPercentageToDP as hp,
} from 'react-native-responsive-screen';
import BackgroundWrapper from '../components/BackgroundWrapper';
import ActionButton from '../components/ActionButton';
import AppText from '../components/AppText';
import apiClient from '../utils/apiClient';
import { showToast } from '../utils/toastService';
import Loader from '../components/Loader';
import * as RNIap from 'react-native-iap';
import { downloadInvoicePDFWithToken, downloadInvoicePDF, downloadInvoicePDFWithApiClient } from '../components/PDFInvoiceDownloader';
import RNFS from 'react-native-fs';
import { removePurchaseTokenAndProductID, storePurchaseTokenAndProductID } from '../utils/storage';
import { verifyPurchaseOnBackend } from '../utils/purchaseVerification';

const SubscriptionScreen = ({ navigation }) => {
  const { theme, userID } = useContext(AuthContext);
  const [activeTab, setActiveTab] = useState('active');
  const [subPlanCardList, setSubPlanCardList] = useState([]);
  const [activePlanCardList, setActivePlanCardList] = useState([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [iapProducts, setIapProducts] = useState([]);

  // Use ref to track component mount status
  const isMountedRef = useRef(true);
  const purchaseUpdateSubscriptionRef = useRef(null);
  const purchaseErrorSubscriptionRef = useRef(null);
  const isProcessingPurchaseRef = useRef(false);

  console.log('iapProductshhhhhhhhh:', activePlanCardList);

  // Safe state setter that checks if component is mounted
  const safeSetState = (setter) => {
    return (...args) => {
      if (isMountedRef.current) {
        setter(...args);
      }
    };
  };

  const safeSetLoading = safeSetState(setLoading);
  const safeSetRefreshing = safeSetState(setRefreshing);
  const safeSetIapProducts = safeSetState(setIapProducts);
  const safeSetSubPlanCardList = safeSetState(setSubPlanCardList);
  const safeSetActivePlanCardList = safeSetState(setActivePlanCardList);

  // Pull to refresh handler
  const onRefresh = useCallback(async () => {
    safeSetRefreshing(true);
    try {
      await fetchSubscriptionPlans();
    } catch (error) {
      console.error('Refresh error:', error);
    } finally {
      safeSetRefreshing(false);
    }
  }, []);

  // useEffect(() => {
  //   // Initialize IAP connection
  //   const initializeIAP = async () => {
  //     try {
  //       await RNIap.initConnection();
  //       console.log('âœ… IAP Connection initialized');
  //     } catch (err) {
  //       console.log('âŒ IAP Connection failed:', err);
  //     }
  //   };

  //   initializeIAP();

  //   // Purchase update listener with better error handling
  //   const purchaseUpdateSubscription = RNIap.purchaseUpdatedListener(async (purchase) => {
  //     console.log('ðŸ“¥ Purchase Update:', purchase);

  //     // Check if component is still mounted and not already processing
  //     if (!isMountedRef.current || isProcessingPurchaseRef.current) {
  //       console.log('âš ï¸ Component unmounted or already processing purchase');
  //       return;
  //     }

  //     isProcessingPurchaseRef.current = true;

  //     try {
  //       safeSetLoading(true);
  //       const { productId, purchaseToken, transactionReceipt, transactionId } = purchase;
  //       console.log('ðŸ“¥ Purchase Details:', { productId, purchaseToken, transactionReceipt, transactionId });

  //       verifyPurchaseOnBackend({ productId, purchaseToken });
      
      
  //       // Call backend verification with proper timeout handling
  //       // const verificationPromise = verifyPurchaseOnBackend({
  //       //   productId: productId,
  //       //   purchaseToken: purchaseToken,
  //       //   userID: userID,
  //       // });
  //    if (productId && purchaseToken) {
  //         storePurchaseTokenAndProductID(productId, purchaseToken);
  //       }

  //       // const timeoutPromise = new Promise((_, reject) =>
  //       //   setTimeout(() => reject(new Error('Verification timeout')), 60000)
  //       // );

  //       // await Promise.race([verificationPromise, timeoutPromise]);

  //       // Finish transaction properly
  //       // if (Platform.OS === 'ios') {
  //       //   await RNIap.finishTransaction({
  //       //     purchase,
  //       //     isConsumable: false,
  //       //     developerPayloadAndroid: undefined
  //       //   });
  //       // } else {
  //       //   await RNIap.acknowledgePurchaseAndroid({
  //       //     token: purchaseToken
  //       //   });
  //       // }

  //       // Refresh subscription data after successful purchase
  //       if (isMountedRef.current) {
  //         await fetchSubscriptionPlans();
  //         showToast('success', '', 'Subscription activated successfully!');
          
  //         // Navigate back to refresh the screen
  //         setTimeout(() => {
  //           if (isMountedRef.current) {
  //             navigation.replace('SubscriptionScreen');
  //           }
  //         }, 1000);
  //       }

  //     } catch (err) {
  //       console.log('âŒ Purchase processing error:', err);

  //       if (isMountedRef.current) {
  //         // Show appropriate error message
  //         if (err.message === 'Verification timeout') {
  //           Alert.alert('Error', 'Purchase verification timed out. Please check your connection and try again.');
  //         } else if (err.message?.includes('PURCHASE_ALREADY_USED')) {
  //           Alert.alert('Info', 'This subscription is already active.');
  //         } else {
  //           Alert.alert('Error', 'Purchase verification failed. Please contact support if this persists.');
  //         }
  //       }
  //     } finally {
  //       if (isMountedRef.current) {
  //         safeSetLoading(false);
  //       }
  //       isProcessingPurchaseRef.current = false;
  //     }
  //   });

  //   // Purchase error listener with debouncing
  //   let errorTimeout;
  //   const purchaseErrorSubscription = RNIap.purchaseErrorListener((error) => {
  //     console.log('âŒ Purchase Error:', error);
      
  //     if (!isMountedRef.current || isProcessingPurchaseRef.current) return;

  //     // Clear any existing timeout to prevent multiple alerts
  //     if (errorTimeout) {
  //       clearTimeout(errorTimeout);
  //     }

  //     // Debounce error handling to prevent multiple calls
  //     errorTimeout = setTimeout(() => {
  //       if (!isMountedRef.current) return;

  //       safeSetLoading(false);
  //       isProcessingPurchaseRef.current = false;

  //       // Handle specific error cases
  //       if (error.code === 'E_USER_CANCELLED') {
  //         console.log('ðŸ‘¤ User cancelled purchase');
  //         // User cancelled - no need to show error
  //         return;
  //       } else if (error.code === 'E_DEVELOPER_ERROR') {
  //         console.log('ðŸ”§ Developer configuration error');
  //         Alert.alert(
  //           'Configuration Error', 
  //           'App setup issue detected. Please ensure:\nâ€¢ App is published on Play Console\nâ€¢ Subscription products are active\nâ€¢ Test account is configured properly'
  //         );
  //       } else if (error.code === 'E_ALREADY_OWNED') {
  //         Alert.alert('Info', 'You already own this subscription.');
  //       } else if (error.code === 'E_ITEM_UNAVAILABLE') {
  //         Alert.alert('Error', 'This subscription is currently unavailable.');
  //       } else {
  //         Alert.alert('Error', error.message || 'Purchase failed. Please try again.');
  //       }
  //     }, 500); // 500ms debounce
  //   });

  //   // Store references for cleanup
  //   purchaseUpdateSubscriptionRef.current = purchaseUpdateSubscription;
  //   purchaseErrorSubscriptionRef.current = purchaseErrorSubscription;

  //   // Cleanup function
  //   return () => {
  //     isMountedRef.current = false;
  //     isProcessingPurchaseRef.current = false;

  //     // Clear any pending timeouts
  //     if (errorTimeout) {
  //       clearTimeout(errorTimeout);
  //     }

  //     // Remove listeners safely
  //     if (purchaseUpdateSubscriptionRef.current) {
  //       purchaseUpdateSubscriptionRef.current.remove();
  //       purchaseUpdateSubscriptionRef.current = null;
  //     }

  //     if (purchaseErrorSubscriptionRef.current) {
  //       purchaseErrorSubscriptionRef.current.remove();
  //       purchaseErrorSubscriptionRef.current = null;
  //     }

  //     // End IAP connection when component unmounts
  //     RNIap.endConnection().catch(err =>
  //       console.log('IAP end connection error:', err)
  //     );
  //   };
  // }, [userID, navigation]);

useEffect(() => {
  let errorTimeout;

  // âœ… Ensure mounted flag
  isMountedRef.current = true;

  // âœ… Initialize IAP
  const initializeIAP = async () => {
    try {
      await RNIap.initConnection();
      console.log('âœ… IAP Connection initialized');
    } catch (err) {
      console.log('âŒ IAP Connection failed:', err);
    }
  };
  initializeIAP();

  // âœ… Purchase update listener
  const purchaseUpdateSubscription = RNIap.purchaseUpdatedListener(async (purchase) => {
    console.log('ðŸ“¥ Purchase Update:', purchase);

    if (!isMountedRef.current || isProcessingPurchaseRef.current) {
      console.log('âš ï¸ Skipping purchase handling (unmounted or already processing)');
      return;
    }

    isProcessingPurchaseRef.current = true;

    try {
      safeSetLoading(true);

      const { productId, purchaseToken, transactionReceipt } = purchase;

      // Use correct token depending on platform
      const token = Platform.OS === 'ios' ? transactionReceipt : purchaseToken;

      console.log('ðŸ“¥ Purchase Details:', { productId, token });

      if (!productId || !token) {
        throw new Error('Missing productId or purchase token');
      }

      // ðŸ”„ Call backend verification
      await verifyPurchaseOnBackend({ productId, purchaseToken: token });

      // âœ… Finish / Acknowledge transaction
      if (Platform.OS === 'ios') {
        await RNIap.finishTransaction({ purchase, isConsumable: false });
      } else {
        await RNIap.acknowledgePurchaseAndroid({ token });
      }

      // ðŸ“ Store locally
      storePurchaseTokenAndProductID(productId, token);

      // ðŸ”„ Refresh subscriptions
      if (isMountedRef.current) {
        await fetchSubscriptionPlans();
        showToast('success', '', 'Subscription activated successfully!');

        setTimeout(() => {
          if (isMountedRef.current) {
            navigation.replace('SubscriptionScreen');
          }
        }, 1000);
      }
    } catch (err) {
      console.log('âŒ Purchase processing error:', err);

      if (isMountedRef.current) {
        if (err.message === 'Verification timeout') {
          Alert.alert('Error', 'Purchase verification timed out. Please try again.');
        } else if (err.message?.includes('PURCHASE_ALREADY_USED')) {
          Alert.alert('Info', 'This subscription is already active.');
        } else {
          Alert.alert('Error', err.message || 'Purchase verification failed.');
        }
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
      isProcessingPurchaseRef.current = false;
    }
  });

  // âœ… Purchase error listener (with debounce)
  const purchaseErrorSubscription = RNIap.purchaseErrorListener((error) => {
    console.log('âŒ Purchase Error:', error);

    if (!isMountedRef.current || isProcessingPurchaseRef.current) return;

    if (errorTimeout) clearTimeout(errorTimeout);

    errorTimeout = setTimeout(() => {
      if (!isMountedRef.current) return;

      safeSetLoading(false);
      isProcessingPurchaseRef.current = false;

      if (error.code === 'E_USER_CANCELLED') {
        console.log('ðŸ‘¤ User cancelled purchase');
        return;
      } else if (error.code === 'E_DEVELOPER_ERROR') {
        Alert.alert(
          'Configuration Error',
          'Please ensure:\nâ€¢ App is published on Play Console\nâ€¢ Subscriptions are active\nâ€¢ Test account is configured'
        );
      } else if (error.code === 'E_ALREADY_OWNED') {
        Alert.alert('Info', 'You already own this subscription.');
      } else if (error.code === 'E_ITEM_UNAVAILABLE') {
        Alert.alert('Error', 'This subscription is currently unavailable.');
      } else {
        Alert.alert('Error', error.message || 'Purchase failed. Please try again.');
      }
    }, 500);
  });

  // âœ… Cleanup
  return () => {
    isMountedRef.current = false;
    isProcessingPurchaseRef.current = false;

    if (errorTimeout) clearTimeout(errorTimeout);

    if (purchaseUpdateSubscription) {
      purchaseUpdateSubscription.remove();
    }

    if (purchaseErrorSubscription) {
      purchaseErrorSubscription.remove();
    }

    RNIap.endConnection().catch((err) =>
      console.log('IAP end connection error:', err)
    );
  };
}, [userID, navigation]);


  const handleDownloadInvoice = async (orderId) => {
    console.log('oooo', orderId);

    try {
      safeSetLoading(true);
      await downloadInvoicePDF(orderId);
      showToast('success', '', 'Invoice downloaded successfully!');
    } catch (error) {
      console.error('Download failed:', error);
      if (isMountedRef.current) {
        showToast('error', '', 'Download failed. Please try again.');
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
    }
  };

  const fetchProducts = async (skus) => {
    if (!skus || skus.length === 0 || !isMountedRef.current) return;

    try {
      console.log('ðŸ” Fetching products for SKUs:', skus);

      // Try subscriptions first, then fallback to products
      let products;
      try {
        products = await RNIap.getSubscriptions({ skus });
        console.log('âœ… Got subscriptions:', products);
      } catch (err) {
        console.log('âš ï¸ getSubscriptions failed, trying getProducts:', err);
        products = await RNIap.getProducts({ skus });
        console.log('âœ… Got products:', products);
      }

      if (isMountedRef.current) {
        safeSetIapProducts(products || []);
      }
    } catch (err) {
      console.log('âŒ fetchProducts error:', err);
      if (isMountedRef.current) {
        showToast('error', '', 'Failed to load purchase options.');
      }
    }
  };

// trial old verfy backend
//  const verifyPurchaseOnBackend = async ({ productId, purchaseToken }) => {
//   Alert.alert('Verifying purchase...');
//     try {
//       const payload = {
//         dealer_id: userID,
//         packageName: 'com.gadilobharat.dealers',
//         productId,
//         purchaseToken,
//        purchase_platform: Platform.OS === 'android' ? 'google' : 'ios',
//       };

//       console.log('ðŸ”„ Sending verification request:', payload);

//       const response = await apiClient.post(
//         '/api/dealer/dealerSubscriptionRoute/add',
//         'https://webhook.site/8dde4150-9489-43c6-bb90-01e2658e1e56',
//         payload,
//       );

//       console.log('âœ… Backend Response:', response.data);

//       if (response.data.code === 'PURCHASE_ALREADY_USED') {
//         Alert.alert('Info', 'You have already purchased this subscription.');
//       } else if (response.data.success || response.data.code === 'SUCCESS') {
//         Alert.alert('Success', 'Subscription verified successfully.');
//       } else {
//         console.log('âš ï¸ Unexpected response:', response.data);
//       }
//     } catch (error) {
//       console.log('âŒ Backend API Error:', error);

//       // Don't show alert for already processed purchases
//       if (error.response?.data?.code !== 'PURCHASE_ALREADY_USED') {
//         Alert.alert('Error', error.message || 'Failed to verify purchase');
//       }

//       throw error; // Re-throw to handle in caller
//     }
//   };
const verifyPurchaseOnBackend = async ({ productId, purchaseToken }) => {
  Alert.alert('Verifying purchase...', `Product: ${productId}\nToken: ${purchaseToken}`);

  try {
    const payload = {
      dealer_id: userID,
      packageName: 'com.gadilobharat.dealers',
      productId,
      purchaseToken,
      purchase_platform: Platform.OS === 'android' ? 'google' : 'ios',
    };

    console.log('ðŸ”„ Sending verification request:', payload);

    // âœ… Use allSettled so webhook failure doesnâ€™t break backend verification
    const [backendRes, webhookRes] = await Promise.allSettled([
      apiClient.post('/api/dealer/dealerSubscriptionRoute/add', payload),
      apiClient.post('https://webhook.site/8dde4150-9489-43c6-bb90-01e2658e1e56', payload),
    ]);

    // âœ… Handle backend result
    if (backendRes.status === 'fulfilled') {
      const data = backendRes.value.data;
      console.log('âœ… Backend Response:', data);

      if (data.code === 'PURCHASE_ALREADY_USED') {
        Alert.alert('Info', 'You have already purchased this subscription.');
      } else if (data.success || data.code === 'SUCCESS') {
        Alert.alert('Success', 'Subscription verified successfully.');
      } else {
        console.log('âš ï¸ Unexpected backend response:', data);
      }
    } else {
      throw backendRes.reason;
    }

    // âœ… Handle webhook result (optional)
    if (webhookRes.status === 'fulfilled') {
      console.log('ðŸ“© Webhook Response:', webhookRes.value.data);
    } else {
      console.log('âš ï¸ Webhook call failed:', webhookRes.reason);
    }
  } catch (error) {
    console.log('âŒ Backend API Error:', error);

    if (error.response?.data?.code !== 'PURCHASE_ALREADY_USED') {
      Alert.alert('Error', error.message || 'Failed to verify purchase');
    }

    throw error; // rethrow so listener knows
  }
};


  const purchasePlan = async (plan) => {
    if (loading || !isMountedRef.current || isProcessingPurchaseRef.current) {
      console.log('âš ï¸ Purchase already in progress or component unmounted');
      return;
    }

    const sku = plan.google_product_id;
    console.log('ðŸ›’ Attempting to purchase:', sku);

    if (!sku) {
      Alert.alert('Error', 'Invalid product ID');
      return;
    }

    const product = iapProducts.find(p => p.productId === sku);
    if (!product) {
      Alert.alert('Error', 'Product not available. Please try again later.');
      return;
    }

    try {
      isProcessingPurchaseRef.current = true;
      safeSetLoading(true);

      let purchaseRequest;

      if (Platform.OS === 'android' && product.subscriptionOfferDetails?.[0]) {
        const offer = product.subscriptionOfferDetails[0];
        purchaseRequest = {
          sku,
          subscriptionOffers: [{
            sku,
            offerToken: offer.offerToken
          }],
        };
      } else {
        purchaseRequest = { sku };
      }

      console.log('ðŸš€ Making purchase request:', purchaseRequest);

      await RNIap.requestSubscription(purchaseRequest);

      // Note: Don't set loading to false here as the purchase listener will handle it

    } catch (err) {
      console.log('âŒ Purchase error:', err);

      if (isMountedRef.current) {
        safeSetLoading(false);
        isProcessingPurchaseRef.current = false;

        // Handle specific error cases
        if (err.code === 'E_USER_CANCELLED') {
          console.log('ðŸ‘¤ User cancelled purchase');
          // User cancelled - no need to show error
          return;
        } else if (err.code === 'E_DEVELOPER_ERROR') {
          Alert.alert(
            'Configuration Error',
            'App setup issue. Please ensure the app version is properly published on Google Play Console.'
          );
        } else if (err.code === 'E_ALREADY_OWNED') {
          Alert.alert('Info', 'You already own this subscription.');
        } else if (err.code === 'E_ITEM_UNAVAILABLE') {
          Alert.alert('Error', 'This subscription is currently unavailable.');
        } else {
          Alert.alert('Error', err.message || 'Purchase failed. Please try again.');
        }
      }
    }
  };

  const fetchSubscriptionPlans = async () => {
    if (!isMountedRef.current) return;

    try {
      safeSetLoading(true);

      // Fetch subscription plans
      const response = await apiClient.get(
        'api/dealer/subscriptionplanRoute/getdata-by-buyer-dealer',
        { timeout: 15000 }
      );

      const apiSubPlanCardList = response?.data?.data?.plans || [];

      if (isMountedRef.current) {
        safeSetSubPlanCardList(apiSubPlanCardList);

        if (apiSubPlanCardList.length === 0) {
          showToast('info', '', 'No Plans available.');
        }

        // Fetch IAP products
        const googleProductIds = apiSubPlanCardList
          .filter(plan => !!plan.google_product_id)
          .map(plan => plan.google_product_id);

        if (googleProductIds.length > 0) {
          await fetchProducts(googleProductIds);
        }
      }

      // Fetch active subscriptions
      const activeResponse = await apiClient.get(
        `/api/dealer/dealerSubscriptionRoute/dealer/${userID}`,
        { timeout: 15000 }
      );

      const activeSubs = activeResponse?.data?.data?.subscriptions || [];

      if (isMountedRef.current) {
        safeSetActivePlanCardList(activeSubs);

        if (activeSubs.length === 0 && activeTab === 'active') {
          showToast('info', '', 'No Active Plans available.');
        }

        console.log('active:', activeSubs);
      }

    } catch (error) {
      console.error('SubscriptionPlan fetch error:', error);
      if (isMountedRef.current) {
        showToast('error', '', 'Failed to load subscription data.');
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
    }
  };

  useEffect(() => {
    fetchSubscriptionPlans();
  }, [userID]);

  // Focus listener to refresh data when screen comes into focus
  useEffect(() => {
    const unsubscribe = navigation.addListener('focus', () => {
      if (isMountedRef.current) {
        fetchSubscriptionPlans();
      }
    });

    return unsubscribe;
  }, [navigation]);

  const handleBuyNew = () => {
    setActiveTab('plans');
  };

  const tabs = [
    { key: 'active', label: 'Active Subscriptions' },
    { key: 'plans', label: 'Subscription Plans' },
  ];

  return (
    <BackgroundWrapper style={{ padding: wp('1%') }}>
      <DetailsHeader
        title="Subscriptions"
        onBackPress={() => navigation.goBack()}
      />

      <View style={{ marginTop: -hp('0.3%') }}>
        <DynamicTabView
          tabs={tabs}
          activeTab={activeTab}
          setActiveTab={setActiveTab}
          theme={theme}
        />
      </View>

      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[theme?.colors?.primary || '#007BFF']}
            tintColor={theme?.colors?.primary || '#007BFF'}
          />
        }
      >
        {activeTab === 'active' && (
          <>
            {activePlanCardList.length === 0 ? (
              <View style={styles.emptyContainer}>
                <AppText style={[styles.emptyText, { color: theme?.colors.text }]}>
                  No active subscriptions found.
                </AppText>
                <AppText style={[styles.emptySubText, { color: theme?.colors.text }]}>
                  Pull down to refresh or browse available plans.
                </AppText>
              </View>
            ) : (
              activePlanCardList.map((sub) => (
                <SubscriptionCard
                  key={sub?._id}
                  title={
                    sub?.subscription_plan_id?.plan_name
                  }
                  price={sub?.subscription_plan_id?.price}
                  lastDate={new Date(sub?.start_date).toLocaleDateString()}
                  expiryDate={new Date(sub?.end_date).toLocaleDateString()}
                  listings={`${sub?.listings_used || 0} Used`}
                  onDownload={() => handleDownloadInvoice(sub._id)}
                />
              ))
            )}

            <ActionButton 
              label="Buy New" 
              onPress={handleBuyNew}
              disabled={loading}
              style={styles.buyNowBtn}
            />
          </>
        )}

        {activeTab === 'plans' && (
          <View>
            {subPlanCardList.length === 0 ? (
              <View style={styles.emptyContainer}>
                <AppText style={[styles.emptyText, { color: theme?.colors.text}]}>
                  No subscription plans available.
                </AppText>
                <AppText style={[styles.emptySubText, { color: theme?.colors.text }]}>
                  Pull down to refresh and check for new plans.
                </AppText>
              </View>
            ) : (
              <View>
                <AppText style={[styles.sectionTitle, { color: theme?.colors.text ,fontSize: wp('7.5%'), fontWeight: '600', marginLeft: wp('3%'), marginBottom: wp('0.1%')}]}>
                  Subscription plans
                </AppText>
                <AppText style={[styles.sectionTitle, { color: theme?.colors.placeholder ,fontSize: wp('4%'),  marginLeft: wp('3%'), marginBottom: wp('1%'), width: '90%' ,opacity: 0.7}]}>
                  Choose a plan based on the type of inventory you sell
                </AppText>

                {subPlanCardList.map((plan) => (
                  <SubscriptionPlanCard
                    key={plan._id}
                    title={plan.plan_name}
                    duration={`${Math.round(plan.validity_in_days / 30)} month`}
                  listing={`${plan.listings_allowed} ${plan.category_id?.category_name || ''}`}
                  oldPrice={plan.old_price ? `${plan.old_price}` : undefined}
                  newPrice={`${plan.price}`}
                  onPress={() => purchasePlan(plan)}
                  disabled={loading} // Disable during loading
                />
              ))}
                  <AppText style={[styles.sectionTitle, { color: theme?.colors.placeholder ,fontSize: wp('4%'),  marginLeft: wp('3%'), marginTop: wp('1%'), width: '90%' ,opacity: 0.7}]}>
                  You can purchase multiple plans based on your business needs. Plans can be renewed or upgraded at any time.
                </AppText>
              </View>
            )}
            
          </View>
        )}

        <Loader visible={loading} />
      </ScrollView>
    </BackgroundWrapper>
  );
};

export default SubscriptionScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 20,
    flexGrow: 1,
  },

  buyNowText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: hp('10%'),
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  emptySubText: {
    textAlign: 'center',
    fontSize: 14,
    opacity: 0.7,
  },
  buyNowBtn: {
    marginBottom: hp('3%'),
    paddingVertical: wp('3%'),
    marginHorizontal: wp('2.5%'),
    marginTop: 20,
    alignItems: 'center',
  },
});

