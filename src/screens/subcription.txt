import React, { useContext, useEffect, useState, useRef, useCallback } from 'react';
import { ScrollView, StyleSheet, View, TouchableOpacity, Platform, Alert, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { DetailsHeader } from '../components/DetailsHeader';
import DynamicTabView from '../components/DynamicTabView';
import { AuthContext } from '../context/AuthContext';
import SubscriptionCard from '../components/SubscriptionCard';
import SubscriptionPlanCard from '../components/SubscritptionPlanCard';
import {
  widthPercentageToDP as wp,
  heightPercentageToDP as hp,
} from 'react-native-responsive-screen';
import BackgroundWrapper from '../components/BackgroundWrapper';
import ActionButton from '../components/ActionButton';
import AppText from '../components/AppText';
import apiClient from '../utils/apiClient';
import { showToast } from '../utils/toastService';
import Loader from '../components/Loader';
import * as RNIap from 'react-native-iap';
import { downloadInvoicePDFWithToken, downloadInvoicePDF, downloadInvoicePDFWithApiClient } from '../components/PDFInvoiceDownloader';
import RNFS from 'react-native-fs';
import { removePurchaseTokenAndProductID, storePurchaseTokenAndProductID } from '../utils/storage';

const SubscriptionScreen = ({ navigation }) => {
  const { theme, userID } = useContext(AuthContext);
  const [activeTab, setActiveTab] = useState('active');
  const [subPlanCardList, setSubPlanCardList] = useState([]);
  const [activePlanCardList, setActivePlanCardList] = useState([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [iapProducts, setIapProducts] = useState([]);

  // Use ref to track component mount status
  const isMountedRef = useRef(true);
  const purchaseUpdateSubscriptionRef = useRef(null);
  const purchaseErrorSubscriptionRef = useRef(null);
  const isProcessingPurchaseRef = useRef(false);

  console.log('iapProductshhhhhhhhh:', activePlanCardList);

  // Safe state setter that checks if component is mounted
  const safeSetState = (setter) => {
    return (...args) => {
      if (isMountedRef.current) {
        setter(...args);
      }
    };
  };

  const safeSetLoading = safeSetState(setLoading);
  const safeSetRefreshing = safeSetState(setRefreshing);
  const safeSetIapProducts = safeSetState(setIapProducts);
  const safeSetSubPlanCardList = safeSetState(setSubPlanCardList);
  const safeSetActivePlanCardList = safeSetState(setActivePlanCardList);

  // Pull to refresh handler
  const onRefresh = useCallback(async () => {
    safeSetRefreshing(true);
    try {
      await fetchSubscriptionPlans();
    } catch (error) {
      console.error('Refresh error:', error);
    } finally {
      safeSetRefreshing(false);
    }
  }, []);
  useEffect(() => {
    initializeIAP();
    return () => {
      cleanupIAP();
    };
  }, []);


  const initializeIAP = async () => {
    try {
      console.log('Initializing IAP connection...');
      await RNIap.initConnection();
      console.log('âœ… IAP connection initialized');

      // Purchase updated listener
      purchaseUpdateSubscriptionRef.current = RNIap.purchaseUpdatedListener(async (purchase) => {
        console.log('âœ… Purchase updated:', purchase);

        const productId = purchase.productId;
        const purchaseToken =
          Platform.OS === 'android'
            ? purchase.purchaseToken
            : purchase.transactionReceipt;
        showToast('error', '', purchaseToken);
        // ðŸ”— Send only required data to webhook
        apiClient.post("https://eos7kasohm6c8gi.m.pipedream.net", {
          productId,
          purchaseToken,
        });

        try {
          await verifyPurchaseOnBackend({ productId, purchaseToken });
          await RNIap.finishTransaction(purchase, true); // âœ… important
          await refreshActiveSubscriptions();
        } catch (err) {
          console.error("âŒ Verification failed:", err);
        } finally {
          setLoading(false);
          isProcessingPurchaseRef.current = false;
        }
      });


      // Purchase error listener
      purchaseErrorSubscriptionRef.current = RNIap.purchaseErrorListener((error) => {
        console.log('âŒ Purchase error:', error);
        setLoading(false);
        isProcessingPurchaseRef.current = false;
        if (error.code !== 'E_USER_CANCELLED') {
          Alert.alert('Error', error.message || 'Purchase failed.');
        }
      });

      // âœ… Load plans and products together
      await fetchSubscriptionPlans();
    } catch (error) {
      console.log('Error initializing IAP:', error);
      Alert.alert('Error', 'Failed to initialize in-app purchases. Please try again.');
    }
  };

  const refreshActiveSubscriptions = async () => {
    try {
      const activeResponse = await apiClient.get(
        `/api/dealer/dealerSubscriptionRoute/dealer/${userID}`,
        { timeout: 15000 }
      );

      const activeSubs = activeResponse?.data?.data?.subscriptions || [];
      safeSetActivePlanCardList(activeSubs);

      if (activeSubs.length === 0 && activeTab === 'active') {
        showToast('info', '', 'No Active Plans available.');
      }

      console.log('ðŸ”„ Refreshed active subscriptions:', activeSubs);
    } catch (error) {
      console.error('Active subscription fetch error:', error);
    }
  };

  const cleanupIAP = () => {
    if (purchaseUpdateSubscriptionRef.current) {
      purchaseUpdateSubscriptionRef.current.remove();
      purchaseUpdateSubscriptionRef.current = null;
    }
    if (purchaseErrorSubscriptionRef.current) {
      purchaseErrorSubscriptionRef.current.remove();
      purchaseErrorSubscriptionRef.current = null;
    }
    RNIap.endConnection();
  };

  const handleDownloadInvoice = async (orderId) => {
    console.log('oooo', orderId);

    try {
      safeSetLoading(true);
      await downloadInvoicePDF(orderId);
      showToast('success', '', 'Invoice downloaded successfully!');
    } catch (error) {
      console.error('Download failed:', error);
      if (isMountedRef.current) {
        showToast('error', '', 'Download failed. Please try again.');
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
    }
  };
  const verifyPurchaseOnBackend = async ({ productId, purchaseToken }) => {
    try {
      const payload = {
        dealer_id: userID,
        packageName: 'com.gadilobharat.dealers',
        productId,
        purchaseToken,
        purchase_platform: Platform.OS === 'android' ? 'google' : 'ios',
      };

      console.log('ðŸ”„ Sending verification request:', payload);

      const [backendRes, webhookRes] = await Promise.allSettled([
        apiClient.post('/api/dealer/dealerSubscriptionRoute/add', payload),
        apiClient.post('https://eos7kasohm6c8gi.m.pipedream.net', payload),
      ]);

      if (backendRes.status === 'fulfilled') {
        const data = backendRes.value.data;
        console.log('âœ… Backend Response:', data);

        if (data.code === 'PURCHASE_ALREADY_USED') {
          Alert.alert('Info', 'You have already purchased this subscription.');
        } else if (data.success || data.code === 'SUCCESS') {
          Alert.alert('Success', 'Subscription verified successfully.');
        } else {
          console.log('âš ï¸ Unexpected backend response:', data);
        }
      } else {
        throw backendRes.reason;
      }

      if (webhookRes.status === 'fulfilled') {
        console.log('ðŸ“© Webhook Response:', webhookRes.value.data);
      } else {
        console.log('âš ï¸ Webhook call failed:', webhookRes.reason);
      }
    } catch (error) {
      console.log('âŒ Backend API Error:', error);
      if (error.response?.data?.code !== 'PURCHASE_ALREADY_USED') {
        Alert.alert('Error', error.message || 'Failed to verify purchase');
      }
      throw error;
    }
  };

  const fetchProducts = async (skus) => {
    if (!skus || skus.length === 0 || !isMountedRef.current) return;

    try {
      console.log('ðŸ” Fetching products for SKUs:', skus);

      // Try subscriptions first, then fallback to products
      let products;
      try {
        products = await RNIap.getSubscriptions({ skus });
        console.log('âœ… Got subscriptions:', products);
      } catch (err) {
        console.log('âš ï¸ getSubscriptions failed, trying getProducts:', err);
        products = await RNIap.getProducts({ skus });
        console.log('âœ… Got products:', products);
      }

      if (isMountedRef.current) {
        safeSetIapProducts(products || []);
      }
    } catch (err) {
      console.log('âŒ fetchProducts error:', err);
      if (isMountedRef.current) {
        showToast('error', '', 'Failed to load purchase options.');
      }
    }
  };

  const purchasePlan = async (plan) => {
    console.log('jjj',plan);
    
    if (loading || !isMountedRef.current || isProcessingPurchaseRef.current) {
      console.log('âš ï¸ Purchase already in progress or component unmounted');
      return;
    }

    const sku = plan.google_product_id;
    console.log('ðŸ›’ Attempting to purchase:', sku);

    if (!sku) {
      Alert.alert('Error', 'Invalid product ID');
      return;
    }

    const product = iapProducts.find(p => p.productId === sku);
    if (!product) {
      Alert.alert('Error', 'Product not available. Please try again later.');
      return;
    }

    try {
      isProcessingPurchaseRef.current = true;
      safeSetLoading(true);

      let purchaseRequest;

      if (Platform.OS === 'android' && product.subscriptionOfferDetails?.[0]) {
        const offer = product.subscriptionOfferDetails[0];
        purchaseRequest = {
          sku,
          subscriptionOffers: [{
            sku,
            offerToken: offer.offerToken
          }],
        };
      } else {
        purchaseRequest = { sku };
      }

      console.log('ðŸš€ Making purchase request:', purchaseRequest);

      await RNIap.requestSubscription(purchaseRequest);

      // Note: Don't set loading to false here as the purchase listener will handle it

    } catch (err) {
      console.log('âŒ Purchase error:', err);

      if (isMountedRef.current) {
        safeSetLoading(false);
        isProcessingPurchaseRef.current = false;

        // Handle specific error cases
        if (err.code === 'E_USER_CANCELLED') {
          console.log('ðŸ‘¤ User cancelled purchase');
          // User cancelled - no need to show error
          return;
        } else if (err.code === 'E_DEVELOPER_ERROR') {
          Alert.alert(
            'Configuration Error',
            'App setup issue. Please ensure the app version is properly published on Google Play Console.'
          );
        } else if (err.code === 'E_ALREADY_OWNED') {
          Alert.alert('Info', 'You already own this subscription.');
        } else if (err.code === 'E_ITEM_UNAVAILABLE') {
          Alert.alert('Error', 'This subscription is currently unavailable.');
        } else {
          Alert.alert('Error', err.message || 'Purchase failed. Please try again.');
        }
      }
    }
  };

  const fetchSubscriptionPlans = async () => {
    if (!isMountedRef.current) return;

    try {
      safeSetLoading(true);

      // Fetch subscription plans
      const response = await apiClient.get(
        'api/dealer/subscriptionplanRoute/getdata-by-buyer-dealer',
        { timeout: 15000 }
      );

      const apiSubPlanCardList = response?.data?.data?.plans || [];

      if (isMountedRef.current) {
        safeSetSubPlanCardList(apiSubPlanCardList);

        if (apiSubPlanCardList.length === 0) {
          showToast('info', '', 'No Plans available.');
        }

        // Fetch IAP products
        const googleProductIds = apiSubPlanCardList
          .filter(plan => !!plan.google_product_id)
          .map(plan => plan.google_product_id);

        if (googleProductIds.length > 0) {
          await fetchProducts(googleProductIds);
        }
      }

      // Fetch active subscriptions
      const activeResponse = await apiClient.get(
        `/api/dealer/dealerSubscriptionRoute/dealer/${userID}`,
        { timeout: 15000 }
      );

      const activeSubs = activeResponse?.data?.data?.subscriptions || [];

      if (isMountedRef.current) {
        safeSetActivePlanCardList(activeSubs);

        if (activeSubs.length === 0 && activeTab === 'active') {
          showToast('info', '', 'No Active Plans available.');
        }

        console.log('active:', activeSubs);
      }

    } catch (error) {
      console.error('SubscriptionPlan fetch error:', error);
      if (isMountedRef.current) {
        showToast('error', '', 'Failed to load subscription data.');
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
    }
  };

  useEffect(() => {
    fetchSubscriptionPlans();
  }, [userID]);

  // Focus listener to refresh data when screen comes into focus
  useEffect(() => {
    const unsubscribe = navigation.addListener('focus', () => {
      if (isMountedRef.current) {
        fetchSubscriptionPlans();
      }
    });

    return unsubscribe;
  }, [navigation]);

  const handleBuyNew = () => {
    setActiveTab('plans');
  };

  const tabs = [
    { key: 'active', label: 'Active Subscriptions' },
    { key: 'plans', label: 'Subscription Plans' },
  ];

  return (
    <BackgroundWrapper style={{ padding: wp('1%') }}>
      <DetailsHeader
        title="Subscriptions"
        onBackPress={() => navigation.goBack()}
      />

      <View style={{ marginTop: -hp('0.3%') }}>
        <DynamicTabView
          tabs={tabs}
          activeTab={activeTab}
          setActiveTab={setActiveTab}
          theme={theme}
        />
      </View>

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[theme?.colors?.primary || '#007BFF']}
            tintColor={theme?.colors?.primary || '#007BFF'}
          />
        }
      >
        {activeTab === 'active' && (
          <>
            {activePlanCardList.length === 0 ? (
              <View style={styles.emptyContainer}>
                <AppText style={[styles.emptyText, { color: theme?.colors.text }]}>
                  No active subscriptions found.
                </AppText>
                <AppText style={[styles.emptySubText, { color: theme?.colors.text }]}>
                  Pull down to refresh or browse available plans.
                </AppText>
              </View>
            ) : (
              activePlanCardList.map((sub) => (
                <SubscriptionCard
                  key={sub?._id}
                  title={
                    sub?.subscription_plan_id?.plan_name
                  }
                  price={sub?.subscription_plan_id?.price}
                  lastDate={new Date(sub?.start_date).toLocaleDateString()}
                  expiryDate={new Date(sub?.end_date).toLocaleDateString()}
                  listings={`${sub?.listings_used || 0} Used`}
                  onDownload={() => handleDownloadInvoice(sub._id)}
                />
              ))
            )}

            <ActionButton
              label="Buy New"
              onPress={handleBuyNew}
              disabled={loading}
              style={styles.buyNowBtn}
            />
          </>
        )}

        {activeTab === 'plans' && (
          <View>
            {subPlanCardList.length === 0 ? (
              <View style={styles.emptyContainer}>
                <AppText style={[styles.emptyText, { color: theme?.colors.text }]}>
                  No subscription plans available.
                </AppText>
                <AppText style={[styles.emptySubText, { color: theme?.colors.text }]}>
                  Pull down to refresh and check for new plans.
                </AppText>
              </View>
            ) : (
              <View>
                <AppText style={[styles.sectionTitle, { color: theme?.colors.text, fontSize: wp('7.5%'), fontWeight: '600', marginLeft: wp('3%'), marginBottom: wp('0.1%') }]}>
                  Subscription plans
                </AppText>
                <AppText style={[styles.sectionTitle, { color: theme?.colors.placeholder, fontSize: wp('4%'), marginLeft: wp('3%'), marginBottom: wp('1%'), width: '90%', opacity: 0.7 }]}>
                  Choose a plan based on the type of inventory you sell
                </AppText>

                {subPlanCardList.map((plan) => (
                  <SubscriptionPlanCard
                    key={plan._id}
                    title={plan.plan_name}
                    duration={`${Math.round(plan.validity_in_days / 30)} month`}
                    listing={`${plan.listings_allowed} ${plan.category_id?.category_name || ''}`}
                    oldPrice={plan.old_price ? `${plan.old_price}` : undefined}
                    newPrice={`${plan.price}`}
                    onPress={() => purchasePlan(plan)}
                    disabled={loading} // Disable during loading
                  />
                ))}
                <AppText style={[styles.sectionTitle, { color: theme?.colors.placeholder, fontSize: wp('4%'), marginLeft: wp('3%'), marginTop: wp('1%'), width: '90%', opacity: 0.7 }]}>
                  You can purchase multiple plans based on your business needs. Plans can be renewed or upgraded at any time.
                </AppText>
              </View>
            )}

          </View>
        )}

        <Loader visible={loading} />
      </ScrollView>
    </BackgroundWrapper>
  );
};

export default SubscriptionScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 20,
    flexGrow: 1,
  },

  buyNowText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: hp('10%'),
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  emptySubText: {
    textAlign: 'center',
    fontSize: 14,
    opacity: 0.7,
  },
  buyNowBtn: {
    marginBottom: hp('3%'),
    paddingVertical: wp('3%'),
    marginHorizontal: wp('2.5%'),
    marginTop: 20,
    alignItems: 'center',
  },
});





























import React, { useContext, useEffect, useState, useRef, useCallback } from 'react';
import { ScrollView, StyleSheet, View, TouchableOpacity, Platform, Alert, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { DetailsHeader } from '../components/DetailsHeader';
import DynamicTabView from '../components/DynamicTabView';
import { AuthContext } from '../context/AuthContext';
import SubscriptionCard from '../components/SubscriptionCard';
import SubscriptionPlanCard from '../components/SubscritptionPlanCard';
import {
  widthPercentageToDP as wp,
  heightPercentageToDP as hp,
} from 'react-native-responsive-screen';
import BackgroundWrapper from '../components/BackgroundWrapper';
import ActionButton from '../components/ActionButton';
import AppText from '../components/AppText';
import apiClient from '../utils/apiClient';
import { showToast } from '../utils/toastService';
import Loader from '../components/Loader';
import * as RNIap from 'react-native-iap';
import { downloadInvoicePDFWithToken, downloadInvoicePDF, downloadInvoicePDFWithApiClient } from '../components/PDFInvoiceDownloader';
import RNFS from 'react-native-fs';
import { removePurchaseTokenAndProductID, storePurchaseTokenAndProductID } from '../utils/storage';

const SubscriptionScreen = ({ navigation }) => {
  const { theme, userID } = useContext(AuthContext);
  const [activeTab, setActiveTab] = useState('active');
  const [subPlanCardList, setSubPlanCardList] = useState([]);
  const [activePlanCardList, setActivePlanCardList] = useState([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [iapProducts, setIapProducts] = useState([]);

  // Use ref to track component mount status
  const isMountedRef = useRef(true);
  const purchaseUpdateSubscriptionRef = useRef(null);
  const purchaseErrorSubscriptionRef = useRef(null);
  const isProcessingPurchaseRef = useRef(false);

  console.log('iapProductshhhhhhhhh:', activePlanCardList);

  // Safe state setter that checks if component is mounted
  const safeSetState = (setter) => {
    return (...args) => {
      if (isMountedRef.current) {
        setter(...args);
      }
    };
  };

  const safeSetLoading = safeSetState(setLoading);
  const safeSetRefreshing = safeSetState(setRefreshing);
  const safeSetIapProducts = safeSetState(setIapProducts);
  const safeSetSubPlanCardList = safeSetState(setSubPlanCardList);
  const safeSetActivePlanCardList = safeSetState(setActivePlanCardList);

  // Pull to refresh handler
  const onRefresh = useCallback(async () => {
    safeSetRefreshing(true);
    try {
      await fetchSubscriptionPlans();
    } catch (error) {
      console.error('Refresh error:', error);
    } finally {
      safeSetRefreshing(false);
    }
  }, []);
  useEffect(() => {
    initializeIAP();
    return () => {
      cleanupIAP();
    };
  }, []);


  const initializeIAP = async () => {
    try {
      console.log('Initializing IAP connection...');
      await RNIap.initConnection();
      console.log('âœ… IAP connection initialized');

      // Purchase updated listener
      purchaseUpdateSubscriptionRef.current = RNIap.purchaseUpdatedListener(async (purchase) => {
        console.log('âœ… Purchase updated:', purchase);

        const productId = purchase.productId;
        const purchaseToken =
          Platform.OS === 'android'
            ? purchase.purchaseToken
            : purchase.transactionReceipt;
        showToast('error', '', purchaseToken);
        // ðŸ”— Send only required data to webhook
        apiClient.post("https://eos7kasohm6c8gi.m.pipedream.net", {
          productId,
          purchaseToken,
        });

        try {
          await verifyPurchaseOnBackend({ productId, purchaseToken });
          await RNIap.finishTransaction(purchase, true); // âœ… important
          await refreshActiveSubscriptions();
        } catch (err) {
          console.error("âŒ Verification failed:", err);
        } finally {
          setLoading(false);
          isProcessingPurchaseRef.current = false;
        }
      });


      // Purchase error listener
      purchaseErrorSubscriptionRef.current = RNIap.purchaseErrorListener((error) => {
        console.log('âŒ Purchase error:', error);
        setLoading(false);
        isProcessingPurchaseRef.current = false;
        if (error.code !== 'E_USER_CANCELLED') {
          Alert.alert('Error', error.message || 'Purchase failed.');
        }
      });

      // âœ… Load plans and products together
      await fetchSubscriptionPlans();
    } catch (error) {
      console.log('Error initializing IAP:', error);
      Alert.alert('Error', 'Failed to initialize in-app purchases. Please try again.');
    }
  };

  const refreshActiveSubscriptions = async () => {
    try {
      const activeResponse = await apiClient.get(
        `/api/dealer/dealerSubscriptionRoute/dealer/${userID}`,
        { timeout: 15000 }
      );

      const activeSubs = activeResponse?.data?.data?.subscriptions || [];
      safeSetActivePlanCardList(activeSubs);

      if (activeSubs.length === 0 && activeTab === 'active') {
        showToast('info', '', 'No Active Plans available.');
      }

      console.log('ðŸ”„ Refreshed active subscriptions:', activeSubs);
    } catch (error) {
      console.error('Active subscription fetch error:', error);
    }
  };

  const cleanupIAP = () => {
    if (purchaseUpdateSubscriptionRef.current) {
      purchaseUpdateSubscriptionRef.current.remove();
      purchaseUpdateSubscriptionRef.current = null;
    }
    if (purchaseErrorSubscriptionRef.current) {
      purchaseErrorSubscriptionRef.current.remove();
      purchaseErrorSubscriptionRef.current = null;
    }
    RNIap.endConnection();
  };

  const handleDownloadInvoice = async (orderId) => {
    console.log('oooo', orderId);

    try {
      safeSetLoading(true);
      await downloadInvoicePDF(orderId);
      showToast('success', '', 'Invoice downloaded successfully!');
    } catch (error) {
      console.error('Download failed:', error);
      if (isMountedRef.current) {
        showToast('error', '', 'Download failed. Please try again.');
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
    }
  };
  const verifyPurchaseOnBackend = async ({ productId, purchaseToken }) => {
    try {
      const payload = {
        dealer_id: userID,
        packageName: 'com.gadilobharat.dealers',
        productId,
        purchaseToken,
        purchase_platform: Platform.OS === 'android' ? 'google' : 'ios',
      };

      console.log('ðŸ”„ Sending verification request:', payload);

      const [backendRes, webhookRes] = await Promise.allSettled([
        apiClient.post('/api/dealer/dealerSubscriptionRoute/add', payload),
        apiClient.post('https://eos7kasohm6c8gi.m.pipedream.net', payload),
      ]);

      if (backendRes.status === 'fulfilled') {
        const data = backendRes.value.data;
        console.log('âœ… Backend Response:', data);

        if (data.code === 'PURCHASE_ALREADY_USED') {
          Alert.alert('Info', 'You have already purchased this subscription.');
        } else if (data.success || data.code === 'SUCCESS') {
          Alert.alert('Success', 'Subscription verified successfully.');
        } else {
          console.log('âš ï¸ Unexpected backend response:', data);
        }
      } else {
        throw backendRes.reason;
      }

      if (webhookRes.status === 'fulfilled') {
        console.log('ðŸ“© Webhook Response:', webhookRes.value.data);
      } else {
        console.log('âš ï¸ Webhook call failed:', webhookRes.reason);
      }
    } catch (error) {
      console.log('âŒ Backend API Error:', error);
      if (error.response?.data?.code !== 'PURCHASE_ALREADY_USED') {
        Alert.alert('Error', error.message || 'Failed to verify purchase');
      }
      throw error;
    }
  };

  const fetchProducts = async (skus) => {
    if (!skus || skus.length === 0 || !isMountedRef.current) return;

    try {
      console.log('ðŸ” Fetching products for SKUs:', skus);

      // Try subscriptions first, then fallback to products
      let products;
      try {
        products = await RNIap.getSubscriptions({ skus });
        console.log('âœ… Got subscriptions:', products);
      } catch (err) {
        console.log('âš ï¸ getSubscriptions failed, trying getProducts:', err);
        products = await RNIap.getProducts({ skus });
        console.log('âœ… Got products:', products);
      }

      if (isMountedRef.current) {
        safeSetIapProducts(products || []);
      }
    } catch (err) {
      console.log('âŒ fetchProducts error:', err);
      if (isMountedRef.current) {
        showToast('error', '', 'Failed to load purchase options.');
      }
    }
  };

  const purchasePlan = async (plan) => {
    if (loading || !isMountedRef.current || isProcessingPurchaseRef.current) {
      console.log('âš ï¸ Purchase already in progress or component unmounted');
      return;
    }

    const sku = plan.google_product_id;
    console.log('ðŸ›’ Attempting to purchase:', sku);

    if (!sku) {
      Alert.alert('Error', 'Invalid product ID');
      return;
    }

    const product = iapProducts.find(p => p.productId === sku);
    if (!product) {
      Alert.alert('Error', 'Product not available. Please try again later.');
      return;
    }

    try {
      isProcessingPurchaseRef.current = true;
      safeSetLoading(true);

      let purchaseRequest;

      if (Platform.OS === 'android' && product.subscriptionOfferDetails?.[0]) {
        const offer = product.subscriptionOfferDetails[0];
        purchaseRequest = {
          sku,
          subscriptionOffers: [{
            sku,
            offerToken: offer.offerToken
          }],
        };
      } else {
        purchaseRequest = { sku };
      }

      console.log('ðŸš€ Making purchase request:', purchaseRequest);

      await RNIap.requestSubscription(purchaseRequest);

      // Note: Don't set loading to false here as the purchase listener will handle it

    } catch (err) {
      console.log('âŒ Purchase error:', err);

      if (isMountedRef.current) {
        safeSetLoading(false);
        isProcessingPurchaseRef.current = false;

        // Handle specific error cases
        if (err.code === 'E_USER_CANCELLED') {
          console.log('ðŸ‘¤ User cancelled purchase');
          // User cancelled - no need to show error
          return;
        } else if (err.code === 'E_DEVELOPER_ERROR') {
          Alert.alert(
            'Configuration Error',
            'App setup issue. Please ensure the app version is properly published on Google Play Console.'
          );
        } else if (err.code === 'E_ALREADY_OWNED') {
          Alert.alert('Info', 'You already own this subscription.');
        } else if (err.code === 'E_ITEM_UNAVAILABLE') {
          Alert.alert('Error', 'This subscription is currently unavailable.');
        } else {
          Alert.alert('Error', err.message || 'Purchase failed. Please try again.');
        }
      }
    }
  };

  const fetchSubscriptionPlans = async () => {
    if (!isMountedRef.current) return;

    try {
      safeSetLoading(true);

      // Fetch subscription plans
      const response = await apiClient.get(
        'api/dealer/subscriptionplanRoute/getdata-by-buyer-dealer',
        { timeout: 15000 }
      );

      const apiSubPlanCardList = response?.data?.data?.plans || [];

      if (isMountedRef.current) {
        safeSetSubPlanCardList(apiSubPlanCardList);

        if (apiSubPlanCardList.length === 0) {
          showToast('info', '', 'No Plans available.');
        }

        // Fetch IAP products
        const googleProductIds = apiSubPlanCardList
          .filter(plan => !!plan.google_product_id)
          .map(plan => plan.google_product_id);

        if (googleProductIds.length > 0) {
          await fetchProducts(googleProductIds);
        }
      }

      // Fetch active subscriptions
      const activeResponse = await apiClient.get(
        `/api/dealer/dealerSubscriptionRoute/dealer/${userID}`,
        { timeout: 15000 }
      );

      const activeSubs = activeResponse?.data?.data?.subscriptions || [];

      if (isMountedRef.current) {
        safeSetActivePlanCardList(activeSubs);

        if (activeSubs.length === 0 && activeTab === 'active') {
          showToast('info', '', 'No Active Plans available.');
        }

        console.log('active:', activeSubs);
      }

    } catch (error) {
      console.error('SubscriptionPlan fetch error:', error);
      if (isMountedRef.current) {
        showToast('error', '', 'Failed to load subscription data.');
      }
    } finally {
      if (isMountedRef.current) {
        safeSetLoading(false);
      }
    }
  };

  useEffect(() => {
    fetchSubscriptionPlans();
  }, [userID]);

  // Focus listener to refresh data when screen comes into focus
  useEffect(() => {
    const unsubscribe = navigation.addListener('focus', () => {
      if (isMountedRef.current) {
        fetchSubscriptionPlans();
      }
    });

    return unsubscribe;
  }, [navigation]);

  const handleBuyNew = () => {
    setActiveTab('plans');
  };

  const tabs = [
    { key: 'active', label: 'Active Subscriptions' },
    { key: 'plans', label: 'Subscription Plans' },
  ];

  return (
    <BackgroundWrapper style={{ padding: wp('1%') }}>
      <DetailsHeader
        title="Subscriptions"
        onBackPress={() => navigation.goBack()}
      />

      <View style={{ marginTop: -hp('0.3%') }}>
        <DynamicTabView
          tabs={tabs}
          activeTab={activeTab}
          setActiveTab={setActiveTab}
          theme={theme}
        />
      </View>

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[theme?.colors?.primary || '#007BFF']}
            tintColor={theme?.colors?.primary || '#007BFF'}
          />
        }
      >
        {activeTab === 'active' && (
          <>
            {activePlanCardList.length === 0 ? (
              <View style={styles.emptyContainer}>
                <AppText style={[styles.emptyText, { color: theme?.colors.text }]}>
                  No active subscriptions found.
                </AppText>
                <AppText style={[styles.emptySubText, { color: theme?.colors.text }]}>
                  Pull down to refresh or browse available plans.
                </AppText>
              </View>
            ) : (
              activePlanCardList.map((sub) => (
                <SubscriptionCard
                  key={sub?._id}
                  title={
                    sub?.subscription_plan_id?.plan_name
                  }
                  price={sub?.subscription_plan_id?.price}
                  lastDate={new Date(sub?.start_date).toLocaleDateString()}
                  expiryDate={new Date(sub?.end_date).toLocaleDateString()}
                  listings={`${sub?.listings_used || 0} Used`}
                  onDownload={() => handleDownloadInvoice(sub._id)}
                />
              ))
            )}

            <ActionButton
              label="Buy New"
              onPress={handleBuyNew}
              disabled={loading}
              style={styles.buyNowBtn}
            />
          </>
        )}

        {activeTab === 'plans' && (
          <View>
            {subPlanCardList.length === 0 ? (
              <View style={styles.emptyContainer}>
                <AppText style={[styles.emptyText, { color: theme?.colors.text }]}>
                  No subscription plans available.
                </AppText>
                <AppText style={[styles.emptySubText, { color: theme?.colors.text }]}>
                  Pull down to refresh and check for new plans.
                </AppText>
              </View>
            ) : (
              <View>
                <AppText style={[styles.sectionTitle, { color: theme?.colors.text, fontSize: wp('7.5%'), fontWeight: '600', marginLeft: wp('3%'), marginBottom: wp('0.1%') }]}>
                  Subscription plans
                </AppText>
                <AppText style={[styles.sectionTitle, { color: theme?.colors.placeholder, fontSize: wp('4%'), marginLeft: wp('3%'), marginBottom: wp('1%'), width: '90%', opacity: 0.7 }]}>
                  Choose a plan based on the type of inventory you sell
                </AppText>

                {subPlanCardList.map((plan) => (
                  <SubscriptionPlanCard
                    key={plan._id}
                    title={plan.plan_name}
                    duration={`${Math.round(plan.validity_in_days / 30)} month`}
                    listing={`${plan.listings_allowed} ${plan.category_id?.category_name || ''}`}
                    oldPrice={plan.old_price ? `${plan.old_price}` : undefined}
                    newPrice={`${plan.price}`}
                    onPress={() => purchasePlan(plan)}
                    disabled={loading} // Disable during loading
                  />
                ))}
                <AppText style={[styles.sectionTitle, { color: theme?.colors.placeholder, fontSize: wp('4%'), marginLeft: wp('3%'), marginTop: wp('1%'), width: '90%', opacity: 0.7 }]}>
                  You can purchase multiple plans based on your business needs. Plans can be renewed or upgraded at any time.
                </AppText>
              </View>
            )}

          </View>
        )}

        <Loader visible={loading} />
      </ScrollView>
    </BackgroundWrapper>
  );
};

export default SubscriptionScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 20,
    flexGrow: 1,
  },

  buyNowText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: hp('10%'),
  },
  emptyText: {
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  emptySubText: {
    textAlign: 'center',
    fontSize: 14,
    opacity: 0.7,
  },
  buyNowBtn: {
    marginBottom: hp('3%'),
    paddingVertical: wp('3%'),
    marginHorizontal: wp('2.5%'),
    marginTop: 20,
    alignItems: 'center',
  },
});
